
# ComposeEntity – генерація Android-застосунку на прикладі "Магазин"

## Структура таблиць (10 одиниць)

Опис таблиць повністю відповідає можливостям CE (довідники, документи, регістри, звіти).

### 1. Product – Товари

**Поля:**  
- `name` – назва товару  
- `sku` – артикул  
- `price` – ціна  
- `unit` – одиниця виміру (шт., кг тощо)  
- `isActive` – активний чи ні  

**Призначення:** список товарів, які продаються або закуповуються.

### 2. Customer – Клієнти

**Поля:**  
- `name` – ім’я або назва  
- `phone` – телефон  
- `email` – email  
- `discountPercent` – знижка у %  

**Призначення:** постійні покупці.

### 3. Supplier – Постачальники

**Поля:**  
- `name` – назва  
- `contactPerson` – відповідальний  
- `phone` – телефон  

**Призначення:** постачальники товарів.

### 4. Invoice – Документ "Продаж клієнту"

**Поля:**  
- `date` – дата продажу  
- `customer` – посилання на клієнта  
- `items` – список товарів (позицій)  

**Призначення:** фіксує продаж товарів клієнтам.

### 5. InvoiceItem – Позиції продажу

**Поля:**  
- `invoiceId` – посилання на документ  
- `product` – товар  
- `quantity` – кількість  
- `price` – ціна за одиницю  

**Призначення:** перелік товарів у кожному продажі.

### 6. Receipt – Документ "Прибуття товару"

**Поля:**  
- `date` – дата  
- `supplier` – постачальник  
- `items` – список позицій  

**Призначення:** фіксує надходження товарів у магазин.

### 7. ReceiptItem – Позиції прибуття

**Поля:**  
- `receiptId` – посилання на документ  
- `product` – товар  
- `quantity` – кількість  
- `price` – закупівельна ціна  

**Призначення:** що саме і скільки було отримано.

### 8. StockRegister – Регістр "Залишки товарів"

**Поля:**  
- `product` – товар  
- `warehouse` – склад  
- `quantity` – залишок  

**Призначення:** розрахунок залишків товарів по складах.

### 9. Warehouse – Склади

**Поля:**  
- `name` – назва складу  
- `address` – адреса  

**Призначення:** розподіл товарів по локаціях.

### 10. CashRegister – Регістр "Гроші"

**Поля:**  
- `date` – дата  
- `customer` – клієнт (якщо є)  
- `supplier` – постачальник (якщо є)  
- `income` – надходження  
- `outcome` – витрата  

**Призначення:** облік грошових операцій.

---

## Порівняння підходів: вручну vs CE

| Компонент                    | Кількість | Рядків |
|-----------------------------|-----------|--------|
| Entity (таблиці)            | 10        | 300    |
| DAO                         | 10        | 400    |
| ViewModel                   | 10        | 600    |
| Repository                  | 10        | 500    |
| UI – списки                 | 10        | 800    |
| UI – форми                  | 10        | 1000   |
| Регістри                    | 2         | 300    |
| Документ/позиції            | 2         | 200    |
| Службовий код               |           | 200+   |
| **Разом**                   |           | ≈4500  |

**Проблеми ручної реалізації:**  
- дублювання DAO/ViewModel/Repo  
- зв’язки таблиць — вручну  
- оновлення регістрів — вручну  
- великі списки/форми через nullable, enum, dropdown  
- пошук/сортування — індивідуально для кожної форми  
- зміни в одній таблиці — багато змін в коді

---

## Підхід CE

Опис однієї ентіті:

```kotlin
@CeGenerator(
  type = GeneratorType.Reference,
  label = "Products",
  generationLevel = GenerationLevel.UI
)
@Entity(tableName = "ref_products")
data class RefProducts(
  @PrimaryKey(autoGenerate = true)
  override var id: Long,
  ...
) : CommonReferenceEntity(...)
```

**Автоматично генерується:**  
- Ext-клас  
- DAO  
- Repository  
- ViewModel  
- UI список і форма  
- логіка проведення документів  
- оновлення регістрів  
- базові звіти

**Програміст пише лише:**  
- опис ентіті  
- точку входу (меню/екран)

---

## Важливо пам’ятати:

- Згенеровані класи з’являються лише після `Clean & Make`
- `Clean` — видаляє їх, `Make` — повертає назад
- Якщо студія "не бачить" класів — зробіть `Clean & Make` ще раз
- Якщо не допомогло:  
  ```bash
  ./gradlew --stop  
  ./gradlew --daemon  
  ```

---

## Можна редагувати згенероване вручну?

Так:  
1. Скопіюйте з `generated/` у власний `.kt`  
2. Вкажіть `generationLevel` до рівня, який хочете зупинити  
3. Нижчі об’єкти залишаються у вашому контролі

---

## Висновок

| Підхід         | Рядків коду | Автоматизація | Обслуговування |
|----------------|-------------|----------------|------------------|
| Ручний         | ~4500       | ні             | важко           |
| ComposeEntity  | ~200        | так            | легко           |
